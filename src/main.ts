import "./style.css";
import { parseGitHubUrl, type ParsedRepo } from "./github-url-parser.ts";
import {
  extractSocialPreview,
  ExtractionError,
  type ExtractionResult,
} from "./image-extractor.ts";
import { downloadImage } from "./downloader.ts";

// ===== DOM Elements =====
const form = document.getElementById("extract-form") as HTMLFormElement;
const input = document.getElementById("repo-url") as HTMLInputElement;
const extractBtn = document.getElementById("extract-btn") as HTMLButtonElement;
const btnText = extractBtn.querySelector(".btn-text") as HTMLSpanElement;
const btnLoader = extractBtn.querySelector(".btn-loader") as HTMLSpanElement;
const inputError = document.getElementById("input-error") as HTMLParagraphElement;

const resultSection = document.getElementById("result-section") as HTMLElement;
const imageStatus = document.getElementById("image-status") as HTMLDivElement;
const previewImage = document.getElementById("preview-image") as HTMLImageElement;
const downloadBtn = document.getElementById("download-btn") as HTMLButtonElement;

const errorSection = document.getElementById("error-section") as HTMLElement;
const errorMessage = document.getElementById("error-message") as HTMLParagraphElement;
const retryBtn = document.getElementById("retry-btn") as HTMLButtonElement;

// ===== State =====
let currentRepo: ParsedRepo | null = null;
let currentResult: ExtractionResult | null = null;

// ===== Event Handlers =====
form.addEventListener("submit", (e) => {
  e.preventDefault();
  handleExtract();
});

retryBtn.addEventListener("click", () => {
  hideError();
  handleExtract();
});

downloadBtn.addEventListener("click", () => {
  handleDownload();
});

// ===== Core Logic =====
async function handleExtract(): Promise<void> {
  hideInputError();
  hideError();
  hideResult();

  const parsed = parseGitHubUrl(input.value);
  if (!parsed) {
    showInputError(
      "Please enter a valid GitHub repository URL (e.g., https://github.com/owner/repo)"
    );
    return;
  }

  currentRepo = parsed;
  setLoading(true);

  try {
    const result = await extractSocialPreview(parsed);
    currentResult = result;
    showResult(result);
  } catch (error) {
    if (error instanceof ExtractionError) {
      showError(error.message);
    } else {
      showError("Something went wrong. Please try again.");
    }
  } finally {
    setLoading(false);
  }
}

function handleDownload(): void {
  if (!currentResult || !currentRepo) return;
  downloadImage(currentResult.blobUrl, currentRepo);
}

// ===== UI Helpers =====
function setLoading(loading: boolean): void {
  extractBtn.disabled = loading;
  input.disabled = loading;
  if (loading) {
    btnText.classList.add("hidden");
    btnLoader.classList.remove("hidden");
  } else {
    btnText.classList.remove("hidden");
    btnLoader.classList.add("hidden");
  }
}

function showInputError(message: string): void {
  inputError.textContent = message;
  inputError.classList.remove("hidden");
}

function hideInputError(): void {
  inputError.textContent = "";
  inputError.classList.add("hidden");
}

function showResult(result: ExtractionResult): void {
  // The blob URL is already fetched â€” just display it
  previewImage.src = result.blobUrl;

  // Show status badge
  if (result.isAutoGenerated) {
    imageStatus.textContent = "Default auto-generated preview";
    imageStatus.className = "status-badge auto-generated";
  } else {
    imageStatus.textContent =
      "This repo uses a custom social preview. Showing the auto-generated version below.";
    imageStatus.className = "status-badge custom-image";
  }
  imageStatus.classList.remove("hidden");
  resultSection.classList.remove("hidden");
  downloadBtn.classList.remove("hidden");
}

function hideResult(): void {
  resultSection.classList.add("hidden");
  downloadBtn.classList.add("hidden");
  imageStatus.classList.add("hidden");

  // Revoke old blob URL to free memory
  if (currentResult?.blobUrl) {
    URL.revokeObjectURL(currentResult.blobUrl);
    currentResult = null;
  }
  previewImage.src = "";
}

function showError(message: string): void {
  hideResult();
  errorMessage.textContent = message;
  errorSection.classList.remove("hidden");
}

function hideError(): void {
  errorSection.classList.add("hidden");
  errorMessage.textContent = "";
}
