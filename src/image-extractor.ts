import type { ParsedRepo } from "./github-url-parser.ts";

export interface ExtractionResult {
  /** A blob URL that can be used directly as an img src or for download */
  blobUrl: string;
  /** Whether the repo uses the default auto-generated image (true) or a custom one (false) */
  isAutoGenerated: boolean;
  /** If the repo uses a custom image, this contains the original custom image URL */
  customImageUrl: string | null;
}

export class ExtractionError extends Error {
  constructor(
    message: string,
    public readonly code:
      | "NOT_FOUND"
      | "CORS_PROXY_FAILED"
      | "NETWORK_ERROR"
      | "PARSE_ERROR"
  ) {
    super(message);
    this.name = "ExtractionError";
  }
}

// ===== CORS Proxy Fallback Chain =====
// Multiple proxies tried in order; if one returns a non-OK status or fails, the next is attempted.
const CORS_PROXIES: Array<(url: string) => string> = [
  (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
  (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
  (url) => `https://corsproxy.io/?url=${encodeURIComponent(url)}`,
];

const OPENGRAPH_BASE = "https://opengraph.githubassets.com";

/**
 * Fetches a URL through the CORS proxy chain, trying each proxy in order
 * until one returns a successful response.
 * Returns the Response from the first proxy that succeeds.
 * Throws if ALL proxies fail.
 */
async function fetchViaProxy(
  targetUrl: string,
  timeoutMs = 15000
): Promise<Response> {
  let lastError: unknown;

  for (const buildProxyUrl of CORS_PROXIES) {
    const proxyUrl = buildProxyUrl(targetUrl);
    try {
      const response = await fetch(proxyUrl, {
        signal: AbortSignal.timeout(timeoutMs),
      });

      // 404 means the target itself was not found — propagate immediately
      if (response.status === 404) {
        throw new ExtractionError(
          "Repository not found. Make sure it exists and is public.",
          "NOT_FOUND"
        );
      }

      // If this proxy returned a non-OK status (e.g. 403), try the next one
      if (!response.ok) {
        lastError = new Error(`Proxy returned status ${response.status}`);
        continue;
      }

      return response;
    } catch (error) {
      // Re-throw NOT_FOUND immediately — no point trying other proxies
      if (error instanceof ExtractionError && error.code === "NOT_FOUND") {
        throw error;
      }
      lastError = error;
      // Try next proxy
    }
  }

  throw new ExtractionError(
    `All CORS proxies failed. ${lastError instanceof Error ? lastError.message : ""}`.trim(),
    "CORS_PROXY_FAILED"
  );
}

/**
 * Builds the direct URL for the auto-generated social preview image.
 * This URL always returns the auto-generated image regardless of custom settings.
 */
function buildAutoGeneratedImageUrl(repo: ParsedRepo): string {
  const cacheBuster = Date.now();
  return `${OPENGRAPH_BASE}/${cacheBuster}/${repo.owner}/${repo.repo}`;
}

/**
 * Fetches an image through the CORS proxy chain and returns a local blob URL.
 */
async function fetchImageAsBlob(imageUrl: string): Promise<string> {
  let response: Response;
  try {
    response = await fetchViaProxy(imageUrl, 30000);
  } catch (error) {
    if (error instanceof ExtractionError && error.code === "NOT_FOUND") {
      throw error;
    }
    throw new ExtractionError(
      "Could not load the preview image. Check your connection and try again.",
      "NETWORK_ERROR"
    );
  }

  const contentType = response.headers.get("content-type") ?? "";
  if (!contentType.startsWith("image/")) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  const blob = await response.blob();
  return URL.createObjectURL(blob);
}

/**
 * Extracts the social preview image information for a GitHub repository.
 *
 * Primary approach: Fetches the repo page HTML via CORS proxy chain, reads the og:image meta tag,
 * then fetches the actual image as a blob for reliable display and download.
 * Fallback: If the HTML proxy fails, validates via GitHub API and fetches the image directly.
 */
export async function extractSocialPreview(
  repo: ParsedRepo
): Promise<ExtractionResult> {
  // Step 1: Determine the og:image URL and whether it's custom or auto-generated
  let ogImageUrl: string | null = null;
  let isAutoGenerated = true;

  try {
    const htmlResult = await fetchOgImageFromHtml(repo);
    ogImageUrl = htmlResult.ogImageUrl;
    isAutoGenerated = htmlResult.isAutoGenerated;
  } catch (error) {
    if (error instanceof ExtractionError && error.code === "NOT_FOUND") {
      throw error;
    }
    // All CORS proxies failed for HTML — fall back to API validation
    await validateRepoExists(repo);
  }

  // Step 2: Fetch the auto-generated image as a blob
  const autoGeneratedUrl = buildAutoGeneratedImageUrl(repo);
  const blobUrl = await fetchImageAsBlob(autoGeneratedUrl);

  return {
    blobUrl,
    isAutoGenerated,
    customImageUrl: isAutoGenerated ? null : ogImageUrl,
  };
}

/**
 * Fetches the GitHub repo page HTML through the CORS proxy chain
 * and extracts the og:image URL.
 */
async function fetchOgImageFromHtml(
  repo: ParsedRepo
): Promise<{ ogImageUrl: string; isAutoGenerated: boolean }> {
  const githubUrl = `https://github.com/${repo.owner}/${repo.repo}`;

  let response: Response;
  try {
    response = await fetchViaProxy(githubUrl);
  } catch (error) {
    if (error instanceof ExtractionError) throw error;
    throw new ExtractionError(
      "Could not reach any CORS proxy.",
      "CORS_PROXY_FAILED"
    );
  }

  const html = await response.text();
  const ogImageUrl = parseOgImage(html);

  if (!ogImageUrl) {
    throw new ExtractionError(
      "Could not find the social preview image in the page metadata.",
      "PARSE_ERROR"
    );
  }

  const isAutoGenerated = ogImageUrl.includes("opengraph.githubassets.com");

  return { ogImageUrl, isAutoGenerated };
}

/**
 * Validates that the repository exists using the GitHub REST API.
 * Throws ExtractionError with NOT_FOUND if the repo doesn't exist.
 */
async function validateRepoExists(repo: ParsedRepo): Promise<void> {
  const apiUrl = `https://api.github.com/repos/${repo.owner}/${repo.repo}`;

  let response: Response;
  try {
    response = await fetch(apiUrl, {
      headers: { Accept: "application/vnd.github.v3+json" },
      signal: AbortSignal.timeout(10000),
    });
  } catch {
    throw new ExtractionError(
      "Network error. Please check your connection and try again.",
      "NETWORK_ERROR"
    );
  }

  if (response.status === 404) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  if (!response.ok) {
    throw new ExtractionError(
      `GitHub API error (status ${response.status}). Try again later.`,
      "NETWORK_ERROR"
    );
  }
}

/**
 * Parses the og:image URL from raw HTML using regex.
 */
function parseOgImage(html: string): string | null {
  // Match <meta property="og:image" content="...">
  const regex =
    /<meta\s+(?:[^>]*?\s+)?property=["']og:image["']\s+(?:[^>]*?\s+)?content=["']([^"']+)["'][^>]*>/i;
  const match = html.match(regex);
  if (match?.[1]) return match[1];

  // Also try reversed attribute order: content before property
  const regexReversed =
    /<meta\s+(?:[^>]*?\s+)?content=["']([^"']+)["']\s+(?:[^>]*?\s+)?property=["']og:image["'][^>]*>/i;
  const matchReversed = html.match(regexReversed);
  return matchReversed?.[1] ?? null;
}
