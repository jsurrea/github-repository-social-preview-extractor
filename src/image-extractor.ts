import type { ParsedRepo } from "./github-url-parser.ts";

export interface ExtractionResult {
  /** A blob URL that can be used directly as an img src or for download */
  blobUrl: string;
  /** Whether the repo uses the default auto-generated image (true) or a custom one (false) */
  isAutoGenerated: boolean;
  /** If the repo uses a custom image, this contains the original custom image URL */
  customImageUrl: string | null;
}

export class ExtractionError extends Error {
  constructor(
    message: string,
    public readonly code:
      | "NOT_FOUND"
      | "CORS_PROXY_FAILED"
      | "NETWORK_ERROR"
      | "PARSE_ERROR"
  ) {
    super(message);
    this.name = "ExtractionError";
  }
}

const CORS_PROXY = "https://corsproxy.io/?url=";
const OPENGRAPH_BASE = "https://opengraph.githubassets.com";

/**
 * Builds the direct URL for the auto-generated social preview image.
 * This URL always returns the auto-generated image regardless of custom settings.
 */
function buildAutoGeneratedImageUrl(repo: ParsedRepo): string {
  const cacheBuster = Date.now();
  return `${OPENGRAPH_BASE}/${cacheBuster}/${repo.owner}/${repo.repo}`;
}

/**
 * Fetches an image through the CORS proxy and returns a local blob URL.
 */
async function fetchImageAsBlob(imageUrl: string): Promise<string> {
  const proxyUrl = `${CORS_PROXY}${encodeURIComponent(imageUrl)}`;

  let response: Response;
  try {
    response = await fetch(proxyUrl, {
      signal: AbortSignal.timeout(30000),
    });
  } catch {
    throw new ExtractionError(
      "Could not load the preview image. Check your connection and try again.",
      "NETWORK_ERROR"
    );
  }

  if (response.status === 404) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  if (!response.ok) {
    throw new ExtractionError(
      `Failed to load image (status ${response.status}).`,
      "NETWORK_ERROR"
    );
  }

  const contentType = response.headers.get("content-type") ?? "";
  if (!contentType.startsWith("image/")) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  const blob = await response.blob();
  return URL.createObjectURL(blob);
}

/**
 * Extracts the social preview image information for a GitHub repository.
 *
 * Primary approach: Fetches the repo page HTML via CORS proxy, reads the og:image meta tag,
 * then fetches the actual image as a blob for reliable display and download.
 * Fallback: If the HTML proxy fails, validates via GitHub API and fetches the image directly.
 */
export async function extractSocialPreview(
  repo: ParsedRepo
): Promise<ExtractionResult> {
  // Step 1: Determine the og:image URL and whether it's custom or auto-generated
  let ogImageUrl: string | null = null;
  let isAutoGenerated = true;

  try {
    const htmlResult = await fetchOgImageFromHtml(repo);
    ogImageUrl = htmlResult.ogImageUrl;
    isAutoGenerated = htmlResult.isAutoGenerated;
  } catch (error) {
    if (error instanceof ExtractionError && error.code === "NOT_FOUND") {
      throw error;
    }
    // CORS proxy failed for HTML â€” fall back to API validation
    await validateRepoExists(repo);
  }

  // Step 2: Fetch the auto-generated image as a blob
  const autoGeneratedUrl = buildAutoGeneratedImageUrl(repo);
  const blobUrl = await fetchImageAsBlob(autoGeneratedUrl);

  return {
    blobUrl,
    isAutoGenerated,
    customImageUrl: isAutoGenerated ? null : ogImageUrl,
  };
}

/**
 * Fetches the GitHub repo page HTML through CORS proxy and extracts the og:image URL.
 */
async function fetchOgImageFromHtml(
  repo: ParsedRepo
): Promise<{ ogImageUrl: string; isAutoGenerated: boolean }> {
  const githubUrl = `https://github.com/${repo.owner}/${repo.repo}`;
  const proxyUrl = `${CORS_PROXY}${encodeURIComponent(githubUrl)}`;

  let response: Response;
  try {
    response = await fetch(proxyUrl, {
      signal: AbortSignal.timeout(15000),
    });
  } catch {
    throw new ExtractionError(
      "Could not reach the CORS proxy.",
      "CORS_PROXY_FAILED"
    );
  }

  if (response.status === 404) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  if (!response.ok) {
    throw new ExtractionError(
      `Unexpected response (status ${response.status})`,
      "NETWORK_ERROR"
    );
  }

  const html = await response.text();
  const ogImageUrl = parseOgImage(html);

  if (!ogImageUrl) {
    throw new ExtractionError(
      "Could not find the social preview image in the page metadata.",
      "PARSE_ERROR"
    );
  }

  const isAutoGenerated = ogImageUrl.includes("opengraph.githubassets.com");

  return { ogImageUrl, isAutoGenerated };
}

/**
 * Validates that the repository exists using the GitHub REST API.
 * Throws ExtractionError with NOT_FOUND if the repo doesn't exist.
 */
async function validateRepoExists(repo: ParsedRepo): Promise<void> {
  const apiUrl = `https://api.github.com/repos/${repo.owner}/${repo.repo}`;

  let response: Response;
  try {
    response = await fetch(apiUrl, {
      headers: { Accept: "application/vnd.github.v3+json" },
      signal: AbortSignal.timeout(10000),
    });
  } catch {
    throw new ExtractionError(
      "Network error. Please check your connection and try again.",
      "NETWORK_ERROR"
    );
  }

  if (response.status === 404) {
    throw new ExtractionError(
      "Repository not found. Make sure it exists and is public.",
      "NOT_FOUND"
    );
  }

  if (!response.ok) {
    throw new ExtractionError(
      `GitHub API error (status ${response.status}). Try again later.`,
      "NETWORK_ERROR"
    );
  }
}

/**
 * Parses the og:image URL from raw HTML using regex.
 */
function parseOgImage(html: string): string | null {
  // Match <meta property="og:image" content="...">
  const regex =
    /<meta\s+(?:[^>]*?\s+)?property=["']og:image["']\s+(?:[^>]*?\s+)?content=["']([^"']+)["'][^>]*>/i;
  const match = html.match(regex);
  if (match?.[1]) return match[1];

  // Also try reversed attribute order: content before property
  const regexReversed =
    /<meta\s+(?:[^>]*?\s+)?content=["']([^"']+)["']\s+(?:[^>]*?\s+)?property=["']og:image["'][^>]*>/i;
  const matchReversed = html.match(regexReversed);
  return matchReversed?.[1] ?? null;
}
